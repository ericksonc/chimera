"""ManagerWidget - Engineering Manager pattern for delegating to Claude Code.

This widget enables Chimera agents to act as "Engineering Managers" who:
- Delegate tactical implementation to Claude Code
- Maintain independent file access for review
- Execute safe bash commands for exploration
- Review and decide on implementation quality

The Manager and Engineer (Claude Code) share the same working directory,
ensuring consistent path semantics for delegation and review.
"""

import asyncio
import logging
import os
import re
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Literal, Optional

from pydantic_ai.exceptions import ApprovalRequired, ModelRetry

from chimera_core.primitives.bash import AgentBashTools, LocalBashExecutor
from chimera_core.threadprotocol.blueprint import ComponentConfig
from chimera_core.widget import StatefulWidget
from chimera_core.widgets.claude_code_widget import ClaudeCodeWidget

if TYPE_CHECKING:
    from pydantic_ai.toolsets import FunctionToolset

    # Using beta API for StepContext as pydantic-graph is still in beta
    # We accept the risk of breaking changes in future releases
    from pydantic_graph.beta import StepContext

    from chimera_core.agent import Agent
logger = logging.getLogger(__name__)


@dataclass
class TaskDefinition:
    """Definition of a task to delegate to Claude Code."""

    id: str
    objective: str
    requirements: list[str]
    acceptance_criteria: list[str]
    context_files: Optional[list[str]] = None
    constraints: Optional[list[str]] = None
    # Permission overrides for this specific task
    allow_bash: bool = False
    max_budget_override: Optional[float] = None
    max_turns_override: Optional[int] = None


@dataclass
class ReviewDecision:
    """Manager's decision after reviewing implementation."""

    decision: Literal["ACCEPT", "REVISE", "REDIRECT", "ROLLBACK"]
    task_id: str
    rationale: str
    specific_feedback: Optional[list[str]] = None
    timestamp: Optional[str] = None

    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = datetime.now(timezone.utc).isoformat()


@dataclass
class ManagerMutation:
    """Mutation for ManagerWidget state changes."""

    action: Literal["assign_task", "update_task_status", "record_review", "log_delegation"]
    payload: dict


class ManagerWidget(StatefulWidget[ComponentConfig, ManagerMutation]):
    """Widget for Engineering Manager pattern with Claude Code delegation.

    This widget provides:
    - Independent readonly file access for review (with ApprovalRequired for out-of-cwd)
    - Safe bash commands for exploration (whitelist-based)
    - Git convenience methods for code review
    - Task delegation to Claude Code with shared cwd
    - Review and decision framework

    Configuration:
        cwd: Working directory for both Manager and Engineer
        review_dir: Directory for storing review files
        default_max_budget: Default budget for delegated tasks
        auto_delegate: If True, automatically delegate without confirmation

    State:
        current_task: Currently active task
        task_history: All completed tasks
        total_delegations: Count of delegations
    """

    # component_class_name auto-generated by PluginMeta
    component_version = "1.0.0"

    # Whitelist of safe bash commands for Manager
    SAFE_BASH_PATTERNS = [
        r"^git\s+",  # All git commands (we'll add --no-pager)
        r"^gh\s+(pr\s+(list|view|status|diff|checks)|repo\s+view|api\s+)",  # GitHub CLI (read-only PR/repo viewing)
        r"^ls(\s+.*)?$",
        r"^pwd$",
        r"^wc(\s+.*)?$",
        r"^tree(\s+.*)?$",
        r"^cat(\s+.*)?$",
        r"^head(\s+.*)?$",
        r"^tail(\s+.*)?$",
        r"^file(\s+.*)?$",
        r"^stat(\s+.*)?$",
    ]

    def __init__(
        self,
        cwd: Optional[str] = None,
        review_dir: Optional[str] = None,
        default_max_budget: float = 5.0,
        auto_delegate: bool = False,
    ):
        """Initialize ManagerWidget.

        Args:
            cwd: Working directory (defaults to current directory).
                 Both Manager and Engineer will use this as base path.
            review_dir: Directory for review files (defaults to cwd/reviews).
            default_max_budget: Default budget for delegated tasks in USD.
            auto_delegate: If True, skip delegation confirmation.
        """
        super().__init__()
        self.cwd = Path(cwd or os.getcwd()).resolve()
        self.review_dir = Path(review_dir or (self.cwd / "reviews"))
        self.review_dir.mkdir(parents=True, exist_ok=True)

        self.default_max_budget = default_max_budget
        self.auto_delegate = auto_delegate

        # Internal ClaudeCodeWidget with SAME cwd for shared path semantics
        self.claude_code = ClaudeCodeWidget(
            cwd=str(self.cwd),
            allowed_tools=["Read", "Write", "Edit", "Bash", "Glob", "Grep"],
            disallowed_tools=[],  # Manager controls via task-specific overrides
            max_budget_usd=default_max_budget,
            max_turns=10,
        )

        # Bash execution via primitives layer (whitelist mode)
        bash_executor = LocalBashExecutor()
        self.bash_tools = AgentBashTools.create_whitelist(
            executor=bash_executor,
            allowed_patterns=self.SAFE_BASH_PATTERNS,
            cwd=self.cwd,
            timeout=30,
        )

        # State (persisted via mutations)
        self.current_task: Optional[TaskDefinition] = None
        self.task_history: list[dict] = []
        self.total_delegations: int = 0

        # Will be captured from ctx in get_toolset
        self._emit_threadprotocol_event = None
        self._event_loop: Optional[asyncio.AbstractEventLoop] = None

    # ========================================================================
    # Path Validation (ApprovalRequired for out-of-cwd)
    # ========================================================================

    def _validate_path(self, path: str) -> Path:
        """Validate path is within cwd, raise ApprovalRequired if not.

        Args:
            path: Relative or absolute path

        Returns:
            Resolved Path object

        Raises:
            ApprovalRequired: If path is outside working directory
            ModelRetry: If path doesn't exist or other errors
        """
        # Handle both relative and absolute paths
        if Path(path).is_absolute():
            resolved = Path(path).resolve()
        else:
            resolved = (self.cwd / path).resolve()

        # Check if within cwd
        try:
            resolved.relative_to(self.cwd)
        except ValueError:
            raise ApprovalRequired(
                f"Path '{path}' is outside working directory.\n"
                f"Attempted: {resolved}\n"
                f"Allowed: {self.cwd}"
            )

        return resolved

    # ========================================================================
    # Safe Bash Tool (Whitelist-based)
    # ========================================================================

    def _prepare_bash_command(self, command: str) -> str:
        """Prepare bash command with safety modifications.

        - Adds --no-pager to git commands
        - Adds implicit "." to find/grep if no path specified

        Args:
            command: Original command

        Returns:
            Modified safe command
        """
        cmd = command.strip()

        # Add --no-pager to git commands
        if cmd.startswith("git "):
            # Insert --no-pager after "git"
            parts = cmd.split(maxsplit=1)
            if len(parts) == 2:
                cmd = f"git --no-pager {parts[1]}"
            else:
                cmd = "git --no-pager"

        # Add implicit "." to find if no path specified
        if cmd.startswith("find") and not re.search(r"find\s+\S", cmd):
            cmd = "find ."

        # Add implicit "." to grep -r if no path specified
        if re.match(r"^grep\s+-r", cmd) and not re.search(r"grep\s+-r.*\s+\S+$", cmd):
            cmd = cmd + " ."

        return cmd

    async def _execute_bash(self, command: str) -> str:
        """Execute bash command using primitives layer.

        Args:
            command: Shell command to execute

        Returns:
            Combined stdout and stderr

        Raises:
            ModelRetry: If command violates whitelist or execution fails
        """
        # Execute via primitives layer (whitelist validation + execution)
        # ModelRetry is raised automatically for violations or failures
        result = await self.bash_tools.execute(command)

        # Return combined output (BashResult.combined_output handles formatting)
        return str(result.combined_output)

    # ========================================================================
    # Git Convenience Methods
    # ========================================================================

    async def _git_diff(self, ref: Optional[str] = None, path: Optional[str] = None) -> str:
        """Get git diff with --no-pager.

        Args:
            ref: Git ref (commit, branch, etc). None for working tree.
            path: Optional path to limit diff

        Returns:
            Diff output
        """
        cmd = "git --no-pager diff"
        if ref:
            cmd += f" {ref}"
        if path:
            cmd += f" -- {path}"

        return await self._execute_bash(cmd)

    async def _git_status(self) -> str:
        """Get git status with --no-pager."""
        return await self._execute_bash("git --no-pager status")

    async def _git_show(self, ref: str) -> str:
        """Get git show with --no-pager.

        Args:
            ref: Git ref (commit, branch, tag, etc)

        Returns:
            Show output
        """
        return await self._execute_bash(f"git --no-pager show {ref}")

    async def _git_log(self, n: int = 10, oneline: bool = False) -> str:
        """Get git log with --no-pager.

        Args:
            n: Number of commits
            oneline: If True, use --oneline format

        Returns:
            Log output
        """
        cmd = f"git --no-pager log -n {n}"
        if oneline:
            cmd += " --oneline"

        return await self._execute_bash(cmd)

    # ========================================================================
    # Manager Tools
    # ========================================================================

    def get_toolset(self, ctx: "StepContext") -> Optional["FunctionToolset"]:
        """Provide Manager tools for review and delegation.

        Args:
            ctx: Step context with deps for mutation emission

        Returns:
            FunctionToolset with Manager tools
        """
        from pydantic_ai.toolsets import FunctionToolset

        # Capture emit function and event loop for mutation emission
        # ctx.deps is ThreadDeps; PAIDeps is created later during agent execution.
        self._emit_threadprotocol_event = ctx.deps.emit_threadprotocol_event
        self._event_loop = asyncio.get_running_loop()
        logger.debug(
            f"[ManagerWidget] Captured emit function and event loop for instance {self.instance_id}"
        )

        toolset = FunctionToolset()

        @toolset.tool
        async def read_file(path: str) -> str:
            """Read a file for review purposes (readonly access).

            Use this to:
            - Review implementation files after delegation
            - Check existing code before delegating
            - Verify changes made by Engineer

            Path can be relative (e.g., 'src/widgets/manager.py') or absolute.
            Paths outside the working directory require human approval.

            Args:
                path: File path relative to working directory or absolute path

            Returns:
                File contents as text

            Raises:
                ApprovalRequired: If path is outside working directory
                ModelRetry: If file not found or read error
            """
            try:
                resolved_path = self._validate_path(path)

                if not resolved_path.exists():
                    raise ModelRetry(f"File not found: {path}")

                if not resolved_path.is_file():
                    raise ModelRetry(f"Path is not a file: {path}")

                # Read file
                content = resolved_path.read_text()
                logger.info(f"[ManagerWidget] Read file: {path} ({len(content)} chars)")
                return content

            except ApprovalRequired:
                raise  # Re-raise for pydantic-ai to handle
            except UnicodeDecodeError:
                raise ModelRetry(f"File appears to be binary: {path}")
            except PermissionError:
                raise ModelRetry(f"Permission denied: {path}")
            except Exception as e:
                raise ModelRetry(f"Error reading file '{path}': {str(e)}")

        @toolset.tool
        async def list_directory(path: str = ".") -> str:
            """List contents of a directory (readonly access).

            Use this to:
            - Explore directory structure before delegation
            - Verify file organization after delegation
            - Find files for review

            Path can be relative or absolute.
            Paths outside the working directory require human approval.

            Args:
                path: Directory path (default: current directory)

            Returns:
                List of files and directories with types

            Raises:
                ApprovalRequired: If path is outside working directory
                ModelRetry: If directory not found or list error
            """
            try:
                resolved_path = self._validate_path(path)

                if not resolved_path.exists():
                    raise ModelRetry(f"Directory not found: {path}")

                if not resolved_path.is_dir():
                    raise ModelRetry(f"Path is not a directory: {path}")

                # List directory
                entries = []
                for item in sorted(resolved_path.iterdir()):
                    rel_path = item.relative_to(self.cwd)
                    type_str = "dir" if item.is_dir() else "file"
                    entries.append(f"{type_str:6} {rel_path}")

                result = "\n".join(entries) if entries else "(empty directory)"
                logger.info(f"[ManagerWidget] Listed directory: {path} ({len(entries)} items)")
                return result

            except ApprovalRequired:
                raise  # Re-raise for pydantic-ai to handle
            except PermissionError:
                raise ModelRetry(f"Permission denied: {path}")
            except Exception as e:
                raise ModelRetry(f"Error listing directory '{path}': {str(e)}")

        @toolset.tool
        async def safe_bash(command: str) -> str:
            """Execute safe bash commands for exploration and review.

            Allowed commands:
            - git (all commands, with auto --no-pager)
            - gh (pr list/view/status/diff/checks, repo view, api - read-only operations)
            - ls, pwd, wc, tree, cat, head, tail, file, stat
            - find (with implicit "." for safety)
            - grep -r (with implicit "." for safety)

            All commands execute in the working directory.

            Args:
                command: Shell command to execute

            Returns:
                Command output (stdout + stderr)

            Raises:
                ModelRetry: If command is not whitelisted or execution fails
            """
            cmd = command.strip()

            # Check against whitelist
            if not any(re.match(pattern, cmd) for pattern in self.SAFE_BASH_PATTERNS):
                allowed = "\n".join(f"  - {p}" for p in self.SAFE_BASH_PATTERNS)
                raise ModelRetry(
                    f"Cannot use non-whitelisted bash command: `{cmd}`\n\n"
                    f"Allowed patterns:\n{allowed}"
                )

            # Prepare command with safety modifications
            safe_cmd = self._prepare_bash_command(cmd)

            logger.info(f"[ManagerWidget] Executing safe bash: {safe_cmd}")
            output = await self._execute_bash(safe_cmd)

            return output

        @toolset.tool
        async def get_git_diff(ref: Optional[str] = None, path: Optional[str] = None) -> str:
            """Get git diff for code review.

            Use this to:
            - Review changes after delegation
            - Compare commits or branches
            - Check working tree changes

            Args:
                ref: Git ref (commit hash, branch, HEAD~1, etc). None for working tree.
                path: Optional path to limit diff to specific file/directory

            Returns:
                Git diff output

            Raises:
                ModelRetry: If git command fails
            """
            logger.info(f"[ManagerWidget] Getting git diff: ref={ref}, path={path}")
            return await self._git_diff(ref, path)

        @toolset.tool
        async def get_git_status() -> str:
            """Get git status to see current state.

            Use this to:
            - Check for uncommitted changes
            - See modified/untracked files
            - Verify clean state before delegation

            Returns:
                Git status output

            Raises:
                ModelRetry: If git command fails
            """
            logger.info("[ManagerWidget] Getting git status")
            return await self._git_status()

        @toolset.tool
        async def get_git_log(n: int = 10, oneline: bool = False) -> str:
            """Get git log to review commit history.

            Use this to:
            - Review recent commits
            - Check commit messages
            - Find commits for comparison

            Args:
                n: Number of commits to show (default: 10)
                oneline: If True, show abbreviated format (default: False)

            Returns:
                Git log output

            Raises:
                ModelRetry: If git command fails
            """
            logger.info(f"[ManagerWidget] Getting git log: n={n}, oneline={oneline}")
            return await self._git_log(n, oneline)

        @toolset.tool
        async def get_git_show(ref: str) -> str:
            """Show a git commit in detail.

            Use this to:
            - Review specific commits
            - See full commit details and diff
            - Verify commit contents

            Args:
                ref: Git ref (commit hash, branch, tag, HEAD~1, etc)

            Returns:
                Git show output with commit details and diff

            Raises:
                ModelRetry: If git command fails or ref not found
            """
            logger.info(f"[ManagerWidget] Showing git ref: {ref}")
            return await self._git_show(ref)

        @toolset.tool
        async def delegate_task(
            objective: str,
            requirements: list[str],
            acceptance_criteria: list[str],
            context_files: Optional[list[str]] = None,
            constraints: Optional[list[str]] = None,
            allow_bash: bool = False,
            max_budget_override: Optional[float] = None,
            max_turns_override: Optional[int] = None,
        ) -> str:
            """Delegate an implementation task to Claude Code (Engineer).

            Use this to:
            - Delegate tactical implementation work
            - Offload file editing and code changes
            - Execute multi-step implementation tasks

            The Engineer will work in the same directory and follow your requirements.
            You can review the results using read_file and get_git_diff.

            Args:
                objective: Clear statement of what needs to be accomplished
                requirements: List of specific requirements (be precise)
                acceptance_criteria: List of criteria for successful completion
                context_files: Optional list of relevant file paths to reference
                constraints: Optional list of what NOT to do
                allow_bash: If True, Engineer can use Bash tool (default: False)
                max_budget_override: Override default budget for this task
                max_turns_override: Override default max turns for this task

            Returns:
                Engineer's response after completing the task

            Raises:
                ModelRetry: If delegation fails or budget exceeded
            """
            # Generate task ID
            task_id = f"task_{self.total_delegations + 1}"

            # Create task definition
            task = TaskDefinition(
                id=task_id,
                objective=objective,
                requirements=requirements,
                acceptance_criteria=acceptance_criteria,
                context_files=context_files or [],
                constraints=constraints or [],
                allow_bash=allow_bash,
                max_budget_override=max_budget_override,
                max_turns_override=max_turns_override,
            )

            logger.info(f"[ManagerWidget] Delegating task {task_id}: {objective}")

            # Store original ClaudeCodeWidget permissions
            original_allowed = self.claude_code.allowed_tools.copy()
            original_budget = self.claude_code.max_budget_usd
            original_turns = self.claude_code.max_turns

            try:
                # Apply task-specific overrides
                if not allow_bash and "Bash" in self.claude_code.allowed_tools:
                    self.claude_code.allowed_tools.remove("Bash")
                elif allow_bash and "Bash" not in self.claude_code.allowed_tools:
                    self.claude_code.allowed_tools.append("Bash")

                if max_budget_override is not None:
                    self.claude_code.max_budget_usd = max_budget_override

                if max_turns_override is not None:
                    self.claude_code.max_turns = max_turns_override

                # Format prompt for Engineer
                prompt = self._format_engineer_prompt(task)

                # Record task assignment mutation
                mutation = ManagerMutation(
                    action="assign_task",
                    payload={
                        "task": asdict(task),
                        "timestamp": datetime.now(timezone.utc).isoformat(),
                    },
                )
                self.mutate(mutation)

                # Store as current task
                self.current_task = task

                # Delegate to Claude Code
                logger.info(
                    f"[ManagerWidget] Calling Claude Code with tools={self.claude_code.allowed_tools}, "
                    f"budget=${self.claude_code.max_budget_usd}, turns={self.claude_code.max_turns}"
                )

                # Get toolset from ClaudeCodeWidget
                claude_toolset = self.claude_code.get_toolset(ctx)
                if not claude_toolset:
                    raise ModelRetry("ClaudeCodeWidget toolset not available")

                # Get query_claude_code tool from toolset
                tool_obj = claude_toolset.tools.get("query_claude_code")
                if not tool_obj:
                    raise ModelRetry("query_claude_code tool not found in ClaudeCodeWidget")

                # Call the tool function
                result = await tool_obj.function(
                    prompt=prompt, max_turns=self.claude_code.max_turns
                )

                # Log delegation
                delegation_mutation = ManagerMutation(
                    action="log_delegation", payload={"count": self.total_delegations + 1}
                )
                self.mutate(delegation_mutation)

                logger.info(f"[ManagerWidget] Task {task_id} delegated successfully")

                return (
                    f"Task {task_id} delegated to Engineer.\n\n"
                    f"Engineer's response:\n{str(result)}\n\n"
                    f"Next steps:\n"
                    f"- Use read_file() to review implementation\n"
                    f"- Use get_git_diff() to see changes\n"
                    f"- Use review_implementation() when ready to decide"
                )

            finally:
                # CRITICAL: Always restore original configuration
                self.claude_code.allowed_tools = original_allowed
                self.claude_code.max_budget_usd = original_budget
                self.claude_code.max_turns = original_turns
                logger.debug("[ManagerWidget] Restored original ClaudeCodeWidget configuration")

        @toolset.tool
        async def review_implementation(
            decision: Literal["ACCEPT", "REVISE", "REDIRECT", "ROLLBACK"],
            rationale: str,
            specific_feedback: Optional[list[str]] = None,
        ) -> str:
            """Record your review decision for the current task.

            Use this after reviewing the Engineer's implementation using:
            - read_file() to check code quality
            - get_git_diff() to verify changes
            - get_git_status() to check state

            Decision types:
            - ACCEPT: Requirements met, ready to proceed
            - REVISE: Right direction, needs specific fixes
            - REDIRECT: Fundamental approach issue, needs different strategy
            - ROLLBACK: Changes harmful, need fresh start

            Args:
                decision: Your decision (ACCEPT/REVISE/REDIRECT/ROLLBACK)
                rationale: Explanation of your decision
                specific_feedback: Optional list of specific items to address

            Returns:
                Confirmation of recorded decision

            Raises:
                ModelRetry: If no current task or recording fails
            """
            if not self.current_task:
                raise ModelRetry("No current task to review. Use delegate_task() first.")

            # Create review decision
            review = ReviewDecision(
                decision=decision,
                task_id=self.current_task.id,
                rationale=rationale,
                specific_feedback=specific_feedback,
            )

            logger.info(f"[ManagerWidget] Recording review for {self.current_task.id}: {decision}")

            # Record review mutation
            mutation = ManagerMutation(action="record_review", payload={"review": asdict(review)})
            self.mutate(mutation)

            # Clear current task if ACCEPT or ROLLBACK
            if decision in ["ACCEPT", "ROLLBACK"]:
                self.current_task = None

            # Format response based on decision
            if decision == "ACCEPT":
                return (
                    f"✓ Task {review.task_id} ACCEPTED\n\n"
                    f"Rationale: {rationale}\n\n"
                    f"The implementation meets requirements and is ready to proceed."
                )
            elif decision == "REVISE":
                feedback_str = "\n".join(f"  - {item}" for item in (specific_feedback or []))
                return (
                    f"→ Task {review.task_id} needs REVISION\n\n"
                    f"Rationale: {rationale}\n\n"
                    f"Specific changes needed:\n{feedback_str}\n\n"
                    f"Use delegate_task() again with revised requirements."
                )
            elif decision == "REDIRECT":
                return (
                    f"↻ Task {review.task_id} needs REDIRECT\n\n"
                    f"Rationale: {rationale}\n\n"
                    f"Use delegate_task() with a different approach."
                )
            elif decision == "ROLLBACK":
                return (
                    f"✗ Task {review.task_id} ROLLED BACK\n\n"
                    f"Rationale: {rationale}\n\n"
                    f"Consider using git reset if needed, then delegate with new requirements."
                )

            return "Review recorded."

        @toolset.tool
        async def get_task_status() -> str:
            """Get current task status and history.

            Use this to:
            - Check if there's a task in progress
            - Review task history
            - See delegation statistics

            Returns:
                Current task status and summary
            """
            if self.current_task:
                status = (
                    f"Current Task: {self.current_task.id}\n"
                    f"Objective: {self.current_task.objective}\n"
                    f"Requirements: {len(self.current_task.requirements)} items\n"
                    f"Acceptance Criteria: {len(self.current_task.acceptance_criteria)} items\n"
                    f"Bash allowed: {self.current_task.allow_bash}\n"
                )
            else:
                status = "No current task.\n"

            status += (
                f"\nTotal delegations: {self.total_delegations}\n"
                f"Completed reviews: {len(self.task_history)}\n"
            )

            if self.task_history:
                status += "\nRecent reviews:\n"
                for review in self.task_history[-5:]:  # Last 5
                    status += f"  - {review.get('task_id')}: {review.get('decision')}\n"

            return status

        @toolset.tool
        async def message_claude_code(message: str) -> str:
            """Send a quick, conversational query to Claude Code (Engineer).

            This is a lightweight alternative to delegate_task() for:
            - Quick questions about code ("What does this function do?")
            - Clarifications during a task ("Can you explain this implementation?")
            - Conversational follow-ups ("Thanks, can you also check X?")
            - Simple inquiries that don't need formal task structure

            Unlike delegate_task(), this tool:
            - Takes just a simple message string (no requirements/criteria)
            - Is for quick back-and-forth conversation, not formal task assignment
            - Still maintains session continuity (shares same resume_id)
            - Respects the same constraints (tools, bash permissions, budget)

            When to use message_claude_code vs delegate_task:

            Use message_claude_code for:
            - "What's in the src/widgets directory?"
            - "Explain how the mutation system works"
            - "Can you show me the current git diff?"
            - "What does the read_file tool do?"

            Use delegate_task for:
            - "Add a new feature to handle user authentication"
            - "Refactor the widget to use async/await pattern"
            - "Fix the bug in the validation logic"
            - "Implement the requirements from the design doc"

            Both tools share the same Claude Code session, so conversation
            context is maintained across both message_claude_code calls and
            delegate_task calls.

            Args:
                message: Your question or message for Claude Code

            Returns:
                Claude Code's response as text

            Raises:
                ModelRetry: If query fails or budget exceeded
            """
            logger.info(f"[ManagerWidget] Sending message to Claude Code: {message[:100]}...")

            # Store original ClaudeCodeWidget permissions
            original_allowed = self.claude_code.allowed_tools.copy()
            original_budget = self.claude_code.max_budget_usd
            original_turns = self.claude_code.max_turns

            try:
                # Apply current configuration (no task-specific overrides for messages)
                # This ensures consistent behavior with delegate_task's baseline settings

                # Get toolset from ClaudeCodeWidget
                claude_toolset = self.claude_code.get_toolset(ctx)
                if not claude_toolset:
                    raise ModelRetry("ClaudeCodeWidget toolset not available")

                # Get query_claude_code tool from toolset
                tool_obj = claude_toolset.tools.get("query_claude_code")
                if not tool_obj:
                    raise ModelRetry("query_claude_code tool not found in ClaudeCodeWidget")

                # Call the tool function directly with the message
                result = await tool_obj.function(
                    prompt=message, max_turns=self.claude_code.max_turns
                )

                logger.info("[ManagerWidget] Message sent and response received")

                return str(result)

            finally:
                # CRITICAL: Always restore original configuration
                self.claude_code.allowed_tools = original_allowed
                self.claude_code.max_budget_usd = original_budget
                self.claude_code.max_turns = original_turns
                logger.debug("[ManagerWidget] Restored original ClaudeCodeWidget configuration")

        return toolset

    # ========================================================================
    # Helper Methods
    # ========================================================================

    def _format_engineer_prompt(self, task: TaskDefinition) -> str:
        """Format task definition into prompt for Engineer (Claude Code).

        Args:
            task: Task definition

        Returns:
            Formatted prompt string
        """
        prompt = f"""## Task: {task.objective}

You are working as an implementation engineer reporting to a Manager.
The Manager has delegated this specific task to you.

### Requirements:
"""
        for i, req in enumerate(task.requirements, 1):
            prompt += f"{i}. {req}\n"

        prompt += "\n### Acceptance Criteria:\n"
        for i, criterion in enumerate(task.acceptance_criteria, 1):
            prompt += f"{i}. {criterion}\n"

        if task.context_files:
            prompt += "\n### Context Files:\n"
            for file_path in task.context_files:
                prompt += f"- {file_path}\n"

        if task.constraints:
            prompt += "\n### Constraints (what NOT to do):\n"
            for i, constraint in enumerate(task.constraints, 1):
                prompt += f"{i}. {constraint}\n"

        prompt += """
### Instructions:
- Implement the requirements precisely
- Follow existing code patterns
- Ask clarifying questions if requirements are ambiguous
- Stay within the specified scope
- Commit your work when done
- Report completion with a summary

The Manager will review your work and provide feedback."""

        return prompt

    # ========================================================================
    # StatefulWidget Contract - Mutation Management
    # ========================================================================

    def save_mutation(self, mutation: ManagerMutation) -> None:
        """Save mutation to ThreadProtocol.

        Args:
            mutation: The mutation to save
        """
        logger.debug(f"[ManagerWidget] save_mutation called: {mutation.action}")

        if not self._emit_threadprotocol_event:
            logger.warning("[ManagerWidget] No emit function available - mutation will be DROPPED!")
            return

        # Create event data
        event = {
            "type": "data-app-chimera",
            "data": {"source": self._get_event_source(), "payload": asdict(mutation)},
        }

        # Emit to ThreadProtocol (from worker thread)
        if not self._event_loop:
            logger.error("[ManagerWidget] No event loop captured! Cannot emit from worker thread.")
            return

        asyncio.run_coroutine_threadsafe(self._emit_threadprotocol_event(event), self._event_loop)
        logger.debug("[ManagerWidget] Mutation saved to ThreadProtocol")

    def apply_mutation(self, mutation: ManagerMutation | dict) -> None:
        """Apply mutation to local state.

        Args:
            mutation: The mutation to apply (typed or dict from replay)
        """
        # Handle dict input (from ThreadProtocol replay)
        if isinstance(mutation, dict):
            mutation = ManagerMutation(**mutation)

        logger.debug(f"[ManagerWidget] apply_mutation: {mutation.action}")

        if mutation.action == "assign_task":
            # Reconstruct TaskDefinition from payload
            task_data = mutation.payload.get("task")
            if task_data:
                self.current_task = TaskDefinition(**task_data)
                logger.debug(f"[ManagerWidget] Assigned task: {self.current_task.id}")

        elif mutation.action == "update_task_status":
            task_id = mutation.payload.get("task_id")
            status = mutation.payload.get("status")
            logger.debug(f"[ManagerWidget] Updated task {task_id} status: {status}")

        elif mutation.action == "record_review":
            review_data = mutation.payload.get("review")
            if review_data:
                self.task_history.append(review_data)
                logger.debug(f"[ManagerWidget] Recorded review: {review_data.get('decision')}")

        elif mutation.action == "log_delegation":
            self.total_delegations = mutation.payload.get("count", self.total_delegations + 1)
            logger.debug(f"[ManagerWidget] Total delegations: {self.total_delegations}")

    # ========================================================================
    # Blueprint Serialization
    # ========================================================================

    def _serialize_config(self) -> dict:
        """Serialize widget configuration to dict.

        Returns:
            Config dict with all widget parameters and state
        """
        return {
            "cwd": str(self.cwd),
            "review_dir": str(self.review_dir),
            "default_max_budget": self.default_max_budget,
            "auto_delegate": self.auto_delegate,
            # State
            "current_task": asdict(self.current_task) if self.current_task else None,
            "task_history": self.task_history,
            "total_delegations": self.total_delegations,
            # Internal ClaudeCodeWidget config
            "claude_code_config": self.claude_code._serialize_config(),
        }

    @classmethod
    def from_blueprint_config(cls, config: ComponentConfig, agent: "Agent") -> "ManagerWidget":
        """Deserialize widget from blueprint config.

        Args:
            config: Component configuration
            agent: Agent instance (for context)

        Returns:
            ManagerWidget instance
        """
        widget_config = config.config or {}
        cwd = widget_config.get("cwd")
        if not cwd:
            raise ValueError("ManagerWidget requires 'cwd' in config")

        review_dir = widget_config.get("review_dir")
        default_max_budget = widget_config.get("default_max_budget", 5.0)
        auto_delegate = widget_config.get("auto_delegate", False)

        # Create widget
        widget = cls(
            cwd=cwd,
            review_dir=review_dir,
            default_max_budget=default_max_budget,
            auto_delegate=auto_delegate,
        )

        # Restore instance_id
        widget.instance_id = config.instance_id

        # Restore state
        current_task_data = widget_config.get("current_task")
        if current_task_data:
            widget.current_task = TaskDefinition(**current_task_data)

        widget.task_history = widget_config.get("task_history", [])
        widget.total_delegations = widget_config.get("total_delegations", 0)

        # Restore internal ClaudeCodeWidget
        claude_code_config = widget_config.get("claude_code_config")
        if claude_code_config:
            # Reconstruct ComponentConfig for ClaudeCodeWidget
            claude_config = ComponentConfig(
                class_name="chimera_core.widgets.claude_code_widget.ClaudeCodeWidget",
                version="1.1.0",
                instance_id="manager_claude_code",
                config=claude_code_config,
            )
            widget.claude_code = ClaudeCodeWidget.from_blueprint_config(claude_config, agent)

        return widget
