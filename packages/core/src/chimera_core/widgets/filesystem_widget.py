"""FileSystemWidget - Provides sandboxed file system access to agents.

This widget provides tools for agents to read, write, and edit files within
a configured base directory. Security is enforced via AgentFileTools.

Key features:
- Path sandboxing (all operations restricted to base_path)
- Pattern-based filtering (include/exclude patterns)
- Size limits (configurable max file size)
- Agent-friendly errors (ModelRetry for retryable failures)

Phase 1 (current): Read-only tools (read_file, list_all_paths)
Phase 2 (future): Write tools (write_file, edit_file, create_directory)

This widget is designed to be subclassed for domain-specific use cases:
- PersonalMemoryWidget: Agent-specific memory directory with ambient instructions
- ProjectFilesWidget: Project-level file access with documentation
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Optional

from pydantic_ai import FunctionToolset

from chimera_core.filesystem.editor import LocalFileEditor
from chimera_core.filesystem.security import AgentFileTools
from chimera_core.widget import Widget

if TYPE_CHECKING:
    from pydantic_graph.beta import StepContext

    from chimera_core.agent import Agent
    from chimera_core.protocols import ReadableThreadState
    from chimera_core.threadprotocol.blueprint import ComponentConfig


@dataclass
class FileSystemConfig:
    """Configuration for FileSystemWidget.

    Stored in BlueprintProtocol (Turn 0 config).
    """

    base_path: str  # Required - sandbox boundary
    max_file_size: int = 200_000  # Maximum file size in bytes (default 200KB)
    include_patterns: Optional[list[str]] = None  # Whitelist patterns (e.g., ["*.txt", "docs/*"])
    exclude_patterns: Optional[list[str]] = None  # Blacklist patterns (e.g., ["*.exe", ".git/*"])


class FileSystemWidget(Widget[FileSystemConfig]):
    """Provides file system access to agents with security sandboxing.

    This is a stateless widget - no state mutations, file state lives on disk.
    Tools are logged via ThreadProtocol but actual writes happen directly to filesystem.

    **Available Tools:**
    - read_file(path): Read a file's contents
    - write_file(path, content): Create or overwrite a file
    - edit_file(path, old_string, new_string): Edit a file precisely
    - list_all_paths(prefix?): List all accessible files

    **Security Features:**
    - Path traversal prevention (no escaping base_path)
    - Pattern-based filtering (include/exclude lists)
    - Size limits (configurable max file size)
    - Binary file protection (UTF-8 text files only)

    **Subclassing Pattern:**
    ```python
    class PersonalMemoryWidget(FileSystemWidget):
        def __init__(self, agent_id: str):
            super().__init__(
                base_path=f"/data/agent_memory/{agent_id}",
                include_patterns=["*.txt", "*.md"],
                exclude_patterns=["*/temp/*"]
            )

        async def get_instructions(self, state):
            base = await super().get_instructions(state)
            return base + "\\n\\nThis is your personal memory. Save important information here."
    ```

    Example:
        widget = FileSystemWidget(
            base_path="/Users/me/agent_workspace",
            max_file_size=200_000,
            include_patterns=["*.txt", "*.md", "docs/*"],
            exclude_patterns=["*/archive/*", ".git/*"]
        )
        agent.register_widget(widget)
    """

    # Component metadata
    # component_class_name auto-generated by PluginMeta as "core.widgets.filesystem_widget.FileSystemWidget"
    component_version = "1.0.0"

    def __init__(
        self,
        base_path: Optional[str] = None,
        max_file_size: int = 200_000,
        include_patterns: Optional[list[str]] = None,
        exclude_patterns: Optional[list[str]] = None,
    ):
        """Initialize FileSystemWidget with security constraints.

        Args:
            base_path: Base directory for sandboxing (can be None for subclasses with computed base_path)
            max_file_size: Maximum file size in bytes (default 200KB)
            include_patterns: Optional whitelist of glob patterns
            exclude_patterns: Optional blacklist of glob patterns
        """
        super().__init__()

        self._base_path = Path(base_path).resolve() if base_path else None
        self.max_file_size = max_file_size
        self.include_patterns = include_patterns or []
        self.exclude_patterns = exclude_patterns or []
        self._file_tools = None  # Lazy initialization

    @property
    def base_path(self) -> Path:
        """Get the base path for file operations.

        Subclasses can override this to compute base_path dynamically.

        Returns:
            Path object for base directory

        Raises:
            ValueError: If base_path is None and not overridden by subclass
        """
        if self._base_path is None:
            raise ValueError(
                f"{self.__class__.__name__} has no base_path configured. "
                f"Either pass base_path to __init__() or override the base_path property."
            )
        return self._base_path

    @property
    def file_tools(self) -> AgentFileTools:
        """Get the AgentFileTools instance (lazy initialization).

        Creates file_tools on first access using current base_path.

        Returns:
            AgentFileTools instance

        Raises:
            ValueError: If base_path doesn't exist or is not a directory
        """
        if self._file_tools is None:
            # Validate base_path exists
            if not self.base_path.exists():
                raise ValueError(f"Base path does not exist: {self.base_path}")
            if not self.base_path.is_dir():
                raise ValueError(f"Base path must be a directory: {self.base_path}")

            # Initialize file system components (editor + security wrapper)
            editor = LocalFileEditor(base_path=str(self.base_path))
            self._file_tools = AgentFileTools(
                editor=editor,
                base_path=str(self.base_path),
                max_file_size=self.max_file_size,
                include_patterns=self.include_patterns,
                exclude_patterns=self.exclude_patterns,
            )

        return self._file_tools

    async def get_instructions(self, state: "ReadableThreadState") -> str | None:
        """Provide instructions about file system access.

        Subclasses can override to add domain-specific instructions.

        Returns:
            Instructions for using file system tools
        """
        lines = [
            "# File System Access",
            "",
            f"You have access to files in: {self.base_path}",
            "",
            "**Available tools:**",
            "- `read_file(path)`: Read a file's contents",
            f"  - Max file size: {self.max_file_size:,} bytes",
            "  - Only UTF-8 text files supported",
            "- `write_file(path, content)`: Create or overwrite a file",
            "  - Parent directories created automatically",
            "- `edit_file(path, old_string, new_string)`: Edit a file precisely",
            "  - old_string must appear exactly once in the file",
            "- `list_all_paths(prefix?)`: List all accessible files",
            "",
        ]

        if self.include_patterns:
            lines.append(f"**Allowed patterns:** {', '.join(self.include_patterns)}")
            lines.append("")

        if self.exclude_patterns:
            lines.append(f"**Excluded patterns:** {', '.join(self.exclude_patterns)}")
            lines.append("")

        lines.extend(
            [
                "**Important:**",
                "- All paths are relative to the base path",
                "- Use forward slashes (e.g., `docs/readme.md`)",
                "- Path traversal (`..`) is not allowed",
            ]
        )

        return "\n".join(lines)

    def get_toolset(self, ctx: "StepContext") -> Optional[FunctionToolset]:
        """Provide file system tools to the agent.

        Phase 1: Read-only tools (read_file, list_all_paths)
        Phase 2: Add write tools (write_file, edit_file, create_directory)

        Args:
            ctx: Step context (not used in Phase 1, but required by signature)

        Returns:
            FunctionToolset with file system tools
        """
        toolset = FunctionToolset()

        @toolset.tool
        async def read_file(path: str) -> str:
            """Read the contents of a file.

            Use this tool to examine any file in your working directory.
            The file will be read as UTF-8 text.

            Args:
                path: Relative path to the file (e.g., "notes.txt" or "docs/readme.md")

            Returns:
                File contents as string

            Raises:
                ModelRetry: If file not found, too large, binary, or access denied

            Examples:
                read_file("README.md")  # Read file in root
                read_file("docs/architecture.md")  # Read file in subdirectory
                read_file("src/utils/helper.py")  # Read code file
            """
            return self.file_tools.read_file(path)

        @toolset.tool
        async def list_all_paths(prefix: str = "") -> str:
            """List all accessible files and directories.

            Use this tool to explore the directory structure and see what files
            are available. Results include file paths, types (file/directory),
            and last modified times.

            Args:
                prefix: Optional directory prefix to filter results (e.g., "docs" to list only docs/)
                       If empty, lists everything in the working directory.

            Returns:
                Formatted list of files and directories with metadata

            Examples:
                list_all_paths()  # List everything
                list_all_paths("docs")  # List only files/dirs under docs/
                list_all_paths("src/utils")  # List only under src/utils/
            """
            paths = self.file_tools.list_all_paths(recursive=True, prefix=prefix)

            if not paths:
                if prefix:
                    return f"No files found in '{prefix}/'."
                return "No files found."

            # Group by directories and files
            directories = [p for p in paths if p.type == "directory"]
            files = [p for p in paths if p.type == "file"]

            lines = []

            # Summary
            lines.append(f"Found {len(files)} files and {len(directories)} directories")
            if prefix:
                lines.append(f"(in '{prefix}/')")
            lines.append("")

            # List directories first
            if directories:
                lines.append("**Directories:**")
                for path_info in directories[:50]:  # Limit to 50 dirs
                    lines.append(f"  ðŸ“ {path_info.path}/ (modified {path_info.last_modified})")
                if len(directories) > 50:
                    lines.append(f"  ... and {len(directories) - 50} more directories")
                lines.append("")

            # List files
            if files:
                lines.append("**Files:**")
                for path_info in files[:100]:  # Limit to 100 files
                    lines.append(f"  ðŸ“„ {path_info.path} (modified {path_info.last_modified})")
                if len(files) > 100:
                    lines.append(f"  ... and {len(files) - 100} more files")

            return "\n".join(lines)

        # Phase 2: Write operations
        @toolset.tool
        async def write_file(path: str, content: str) -> str:
            """Write content to a file (create new or overwrite existing).

            Use this tool to create new files or completely replace existing file contents.
            Parent directories will be created automatically if they don't exist.

            Args:
                path: Relative path to the file (e.g., "notes/todo.txt")
                content: The complete content to write to the file

            Returns:
                Success message indicating file was created or updated

            Raises:
                ModelRetry: If access denied, path invalid, or write fails

            Examples:
                write_file("notes.txt", "My notes here")
                write_file("docs/readme.md", "# README\\n\\nProject documentation")
            """
            return self.file_tools.write_file(path, content)

        @toolset.tool
        async def edit_file(path: str, old_string: str, new_string: str) -> str:
            """Edit a file by replacing old_string with new_string.

            Use this tool to make precise edits to existing files. The old_string
            must appear exactly once in the file (unless you want to replace all
            occurrences, which requires a different approach).

            Args:
                path: Relative path to the file
                old_string: Exact text to find and replace
                new_string: Text to replace it with

            Returns:
                Unified diff showing the changes made

            Raises:
                ModelRetry: If file not found, old_string not found, not unique, or edit fails

            Examples:
                edit_file("config.py", "DEBUG = False", "DEBUG = True")
                edit_file("notes.txt", "TODO: review", "DONE: reviewed on 2025-11-05")
            """
            return self.file_tools.edit_file(path, old_string, new_string, replace_all=False)

        return toolset

    # ========================================================================
    # BlueprintProtocol Serialization
    # ========================================================================

    def _serialize_config(self) -> dict:
        """Serialize widget configuration to dict.

        Returns:
            Config dict with paths and security settings
        """
        config = {"base_path": str(self.base_path), "max_file_size": self.max_file_size}

        # Include patterns only if non-empty
        if self.include_patterns:
            config["include_patterns"] = self.include_patterns.copy()
        if self.exclude_patterns:
            config["exclude_patterns"] = self.exclude_patterns.copy()

        return config

    # Note: to_blueprint_config() inherited from BasePlugin

    @classmethod
    def from_blueprint_config(cls, config: "ComponentConfig", agent: "Agent") -> "FileSystemWidget":
        """Deserialize from BlueprintProtocol format.

        Args:
            config: ComponentConfig from Blueprint
            agent: Agent instance that owns this widget

        Returns:
            FileSystemWidget instance with configured security settings
        """
        widget = cls(
            base_path=config.config["base_path"],
            max_file_size=config.config.get("max_file_size", 200_000),
            include_patterns=config.config.get("include_patterns"),
            exclude_patterns=config.config.get("exclude_patterns"),
        )
        widget.instance_id = config.instance_id
        return widget
