"""AgentFileMemoryWidget - Personal file-based memory for agents.

This widget provides each agent with a private, sandboxed filesystem for
maintaining persistent memory across conversations. Files are stored in
a per-agent directory based on the agent's identifier.

Key features:
- Per-agent directory: /Users/ericksonc/chimera-desktop/memory/{agent_slug}/
- Automatic identifier normalization (lowercase, alphanumeric + underscores)
- Text file focus (*.txt, *.md)
- Zero configuration required - uses self.agent.identifier
- Custom instructions emphasizing memory persistence

Use cases:
- Agent personal notes and reminders
- Conversation summaries
- Task tracking
- Knowledge accumulation
- Context that persists across sessions
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING

from chimera_core.threadprotocol.blueprint import ComponentConfig
from chimera_core.widgets.filesystem_widget import FileSystemWidget

if TYPE_CHECKING:
    from pydantic_graph.beta import StepContext

    from chimera_core.agent import Agent
    from chimera_core.protocols import ReadableThreadState


class AgentFileMemoryWidget(FileSystemWidget):
    """Provides agents with personal file-based memory storage.

    Each agent gets a private directory for persistent memory:
    `/Users/ericksonc/chimera-desktop/memory/{agent_slug}/`

    The agent_slug is normalized from the agent's identifier field:
    - Lowercase conversion
    - Non-alphanumeric characters → underscores
    - Example: "Dave's Assistant" → "dave_s_assistant"

    **Zero Configuration Required:**
    This widget discovers the agent via self.agent (set automatically during
    widget registration). No arguments needed, no config stored in blueprint.
    The base_path is computed dynamically from self.agent.identifier.

    **Available Tools:**
    - read_file(path): Read from your memory
    - write_file(path, content): Create or update memory files
    - edit_file(path, old, new): Precisely edit existing memories
    - list_all_paths(prefix?): Browse your stored memories

    **Recommended Patterns:**
    - Use descriptive filenames (notes.txt, todos.md, learnings.md)
    - Organize with subdirectories (tasks/, context/, learnings/)
    - Update existing files rather than creating duplicates
    - Use markdown for structured notes

    Example Usage:
        # In blueprint creation (Python)
        agent = Agent.from_yaml("agents/dave.yaml")
        memory_widget = AgentFileMemoryWidget()  # No args!
        agent.register_widget(memory_widget)

        # Or in blueprint JSON - widget has no config:
        {
          "class_name": "chimera_core.widgets.AgentFileMemoryWidget",
          "version": "1.0.0",
          "instance_id": "memory",
          "config": {}
        }

        # Agent can then:
        # - write_file("notes.txt", "Remembered user prefers brevity")
        # - read_file("context/project_summary.md")
        # - edit_file("todos.md", "- [ ] Task", "- [x] Task")
    """

    # Component metadata
    # component_class_name auto-generated by PluginMeta as "core.widgets.agent_file_memory_widget.AgentFileMemoryWidget"
    component_version = "1.0.0"

    def __init__(self):
        """Initialize memory widget (agent reference set during registration).

        No arguments needed - base_path is computed from self.agent.identifier.
        """
        # Call parent with no base_path - we'll compute it dynamically
        super().__init__(
            base_path=None,  # Computed via base_path property
            max_file_size=500_000,  # 500KB for memory files
            include_patterns=["*.txt", "*.md"],  # Text files only
            exclude_patterns=["temp/*", "*.log"],  # Exclude temp and logs
        )

    @property
    def base_path(self) -> Path:
        """Compute base path dynamically from agent identifier.

        Returns:
            Path to agent's memory directory

        Raises:
            AttributeError: If self.agent is None (shouldn't happen at runtime)
        """
        # Compute agent slug from agent identifier
        agent_slug = re.sub(r"[^a-z0-9]+", "_", self.agent.identifier.lower()).strip("_")

        # Create memory directory path
        memory_base = Path("/Users/ericksonc/chimera-desktop/memory")
        agent_memory_path = memory_base / agent_slug

        # Ensure directory exists
        agent_memory_path.mkdir(parents=True, exist_ok=True)

        return agent_memory_path

    async def get_instructions(self, ctx: "StepContext") -> str | None:
        """Provide memory-specific instructions to the agent.

        Args:
            ctx: Step context with state and deps

        Returns:
            Instructions emphasizing persistent memory usage
        """
        base_instructions = await super().get_instructions(ctx)

        agent_slug = re.sub(r"[^a-z0-9]+", "_", self.agent.identifier.lower()).strip("_")

        memory_instructions = f"""

**Your Personal Memory System**

This is your private, persistent memory. Files stored here remain available
across all conversations. Use this to:

- Remember important context about users, projects, or ongoing work
- Track tasks and todos that span multiple conversations
- Store learnings and insights you want to recall later
- Maintain summaries of complex discussions
- Keep notes on decisions, preferences, or patterns

**Best Practices:**
- Use descriptive filenames (e.g., "user_preferences.txt", "project_context.md")
- Organize with subdirectories (e.g., "tasks/", "context/", "learnings/")
- Update existing files rather than creating duplicates
- Use markdown for structured notes with headers and lists
- Review your memory periodically to keep it current

**Your Memory Location:** `{self.base_path}`
**Agent ID:** {self.agent.identifier} → {agent_slug}
"""

        return base_instructions + memory_instructions

    # ========================================================================
    # BlueprintProtocol Serialization - Zero Config!
    # ========================================================================

    def _serialize_config(self) -> dict:
        """Serialize widget configuration to dict.

        The agent reference is available via self.agent, so we don't need to
        store any configuration in the blueprint.

        Returns:
            Empty dict (no config needed)
        """
        return {}  # No config needed!

    # Note: to_blueprint_config() inherited from BasePlugin

    @classmethod
    def from_blueprint_config(
        cls, config: ComponentConfig, agent: "Agent"
    ) -> "AgentFileMemoryWidget":
        """Deserialize from blueprint (agent reference will be set by register_widgets).

        Args:
            config: ComponentConfig (config dict should be empty)
            agent: Agent instance (passed for consistency, not used here)

        Returns:
            AgentFileMemoryWidget instance
        """
        widget = cls()  # No args!
        widget.instance_id = config.instance_id
        return widget
